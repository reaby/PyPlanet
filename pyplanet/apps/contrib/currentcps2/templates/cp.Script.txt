#Include "TextLib" as TextLib
#Include "MathLib" as MathLib

***OnInit***
***
    declare Boolean needUpdate = False;
    declare Integer lastUpdate = Now;
    declare Integer oldPlayersCount = Players.count;
    declare Integer recordsAmount for Page;
    declare Integer[Text] TimesByLogin;
    declare Integer[Text][Integer] LoginsByCheckpoints;

    declare Integer[Text] Progress;
    declare Text[] SortedLogins;

    recordsAmount = {{ records_amount }};
    Reset();
***


***Loop***
***
    foreach (Event in PendingEvents) {
        if (Event.Type == CMlScriptEvent::Type::MouseClick && Event.Control.HasClass("toggleSpec")) {
            declare x = TextLib::ToInteger(Event.Control.DataAttributeGet("position"));
            if (Players.existskey(x)) {
                if (!InputPlayer.RequestsSpectate) {
                   RequestSpectatorClient(True);
                }
                SetSpectateTarget(Players[x].User.Login);
            }
        }
    }


    foreach (event in RaceEvents) {
       if (event.Type == CTmRaceClientEvent::EType::WayPoint) {
          Times[event.Player.User.Login] = event.RaceTime;
          Progress[event.Player.User.Login] = event.CheckpointInRace;
          Nicknames[event.Player.User.Login] = event.Player.User.Name;
          Times.sort();
          SortedLogins.clear();
          foreach (login => time in Times) {
            SortedLogins.add(login);
          }
          needUpdate = True;
       }
    }

    if (oldPlayersCount != Players.count) {
        oldPlayersCount = Players.count;
        needUpdate = True;
    }

   if (Now - lastUpdate > 250) {
      lastUpdate = Now;
      if (needUpdate == True) {
          needUpdate = False;

          for(x, 0, recordsAmount-1) {

          // begin update widget

              declare frame <=> (Page.GetFirstChild("pos_"^index) as CMlFrame);
              frame.Show();
              (frame.Controls[1] as CMlLabel).Value = ""^Progress[login];
              (frame.Controls[3] as CMlLabel).Value = Nicknames[Login];
              (frame.Controls[5] as CMlLabel).Value = TimeToText(time);
              } else {
                  declare frame <=> (Page.GetFirstChild("pos_"^x) as CMlFrame);
                  frame.Hide();
              }
              index += 1;
          }
      }
   }
}




***
Void Reset() {
    declare Integer[Text] Times for Page;
    declare Integer[Text] Progress for Page;
    declare Text[Text] Nicknames for Page;

    Times.clear();
    Progress.clear();
    Nicknames.clear();
}

Text FormatSec(Real sec) {
    if (sec > 10.) return TextLib::FormatReal(sec,3,False,False);
    return  0 ^ TextLib::FormatReal(sec,3,False,False);
}

Text TimeToText(Integer intime) {
    declare time = MathLib::Abs(intime);
    declare Integer cent = time % 1000;
    declare Integer sec2 = (time / 1000) % 60;
    declare Real sec = 1. * sec2 + cent * 0.001;
    declare Integer min = (time / 60000) % 60;
    declare Integer hour = time / 3600000;
    declare Text sign = "";
    if (intime < 0) sign = "-";
    if (hour > 0) return sign ^ hour ^ "'" ^ TextLib::FormatInteger(min,2) ^ ":" ^ FormatSec(sec);
    if (min == 0) return sign ^ "00:" ^ FormatSec(sec);
    if (min > 10)  return sign ^ min ^ ":" ^ FormatSec(sec);
    return sign ^ 0 ^ min ^ ":" ^ FormatSec(sec);
}

main() {
  wait (InputPlayer != Null);

  +++OnInit+++

  while (True) {
      yield;

      if (!PageIsVisible || InputPlayer == Null) {
  	  		continue;
      }

      +++Loop+++
  }
}
